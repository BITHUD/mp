<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Advanced Music Player</title>

<link rel="manifest" href="/manifest.json">

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Music Player">
<link rel="apple-touch-icon" href="/icons/icon-192x192.png">

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

<style>
  /* Reset */
  * {
    box-sizing: border-box;
  }

  :root {
    /* Spotify-inspired colors */
    --primary-color: #1DB954; /* Spotify Green */
    --background-dark: #121212; /* Very dark grey/black */
    --background-medium: #181818; /* Slightly lighter dark grey */
    --background-light: #282828; /* Even lighter dark grey, almost charcoal */
    --text-color: #FFFFFF; /* White */
    --text-muted: #B3B3B3; /* Light grey */
    --border-color: #333333; /* Darker grey for subtle borders */
    --shadow-color: rgba(0, 0, 0, 0.8); /* Stronger shadow for depth */
    --primary-color-rgb: 29, 185, 84; /* RGB for Spotify Green */
    --error-color: #F44336; /* Red for errors */
    --success-color: #4CAF50; /* Green for success */
  }

  body {
    font-family: 'Inter', sans-serif; /* Use Inter font */
    background-color: var(--background-dark);
    color: var(--text-color);
    margin: 0;
    padding: 20px;
    padding-bottom: 50px; /* Added padding to bottom of body from !test.html */
    display: flex;
    justify-content: center;
    align-items: flex-start; /* Align to top to allow more space for content */
    min-height: 100vh;
    overflow-x: hidden; /* Prevent horizontal scrolling on mobile */
  }
  
  /* --- UI Message/Notification Bar --- */
  .ui-message {
    position: fixed;
    top: -100px; /* Start off-screen */
    left: 50%;
    transform: translateX(-50%);
    padding: 12px 25px;
    border-radius: 25px;
    color: white;
    font-weight: 500;
    z-index: 1000;
    box-shadow: 0 6px 20px rgba(0,0,0,0.6); /* More pronounced shadow from !test.html */
    transition: top 0.4s ease-in-out;
    text-align: center;
    background-color: rgba(40, 40, 40, 0.95); /* Slightly less transparent background from !test.html */
    backdrop-filter: blur(8px); /* Frosted glass effect from !test.html */
    -webkit-backdrop-filter: blur(8px); /* For Safari from !test.html */
  }
  .ui-message.show {
    top: 20px;
  }
  .ui-message.error {
    background-color: var(--error-color);
    box-shadow: 0 6px 20px rgba(244, 67, 54, 0.5); /* Matching shadow from !test.html */
  }
  .ui-message.success {
    background-color: var(--primary-color);
    box-shadow: 0 6px 20px rgba(29, 185, 84, 0.5); /* Matching shadow from !test.html */
  }
  .ui-message.info {
    background-color: #2196F3; /* Blue for info */
    box-shadow: 0 6px 20px rgba(33, 150, 243, 0.5); /* From !test.html */
  }
  
  .container {
    background-color: var(--background-medium);
    border-radius: 16px; /* Softer rounded corners, increased slightly from !test.html */
    box-shadow: 0 12px 45px var(--shadow-color); /* Increased shadow for more depth from !test.html */
    width: 100%;
    max-width: 900px;
    display: flex;
    flex-direction: column;
    overflow: hidden; /* For rounded corners */
  }

  header {
    background-color: var(--background-light);
    padding: 25px 30px; /* More padding from !test.html */
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  header h1 {
    margin: 0;
    font-size: 2.3em; /* Slightly larger title from !test.html */
    color: var(--primary-color);
    font-weight: 700; /* Bolder */
    letter-spacing: -0.03em; /* Tighter letter spacing for titles from !test.html */
  }

  nav.tabs {
    display: flex;
    justify-content: space-around;
    background-color: var(--background-dark);
    border-bottom: 1px solid var(--border-color);
  }

  .tab-button {
    flex-grow: 1;
    padding: 18px 0; /* More padding */
    text-align: center;
    color: var(--text-muted);
    font-weight: 600; /* Semi-bold */
    cursor: pointer;
    transition: background-color 0.25s ease, color 0.25s ease, border-bottom 0.25s ease; /* Transition from !test.html */
    position: relative; /* For active indicator */
    font-size: 1.1em; /* Slightly larger font from !test.html */
  }

  .tab-button:hover:not(.active) {
    background-color: #222222; /* Subtle hover effect */
    color: var(--text-color);
  }

  .tab-button.active {
    color: var(--text-color);
    background-color: var(--background-medium);
    /* Spotify-like active indicator */
    border-bottom: 4px solid var(--primary-color); /* Thicker border from !test.html */
  }

  main {
    flex-grow: 1;
    padding: 30px; /* More padding from !test.html */
  }

  .tab-content {
    display: none;
  }

  .tab-content.active {
    display: block;
  }

  /* Library Tab Specifics */
  .library-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 30px; /* More margin from !test.html */
    gap: 20px; /* More gap from !test.html */
    flex-wrap: wrap;
  }

  .library-controls button {
    background-color: var(--primary-color);
    color: white;
    border: none;
    padding: 16px 25px; /* Increased padding for better touch target and look from !test.html */
    min-height: 52px; /* Increased min-height from !test.html */
    border-radius: 28px; /* Pill-shaped buttons from !test.html */
    cursor: pointer;
    font-size: 1.0em; /* Slightly larger font from !test.html */
    font-weight: 600;
    transition: background-color 0.2s ease, transform 0.15s ease, box-shadow 0.2s ease; /* Transition from !test.html */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4); /* Enhanced shadow from !test.html */
  }
  
  .library-controls button:focus {
      outline: 3px solid rgba(var(--primary-color-rgb), 0.7); /* Thicker, more visible focus from !test.html */
      outline-offset: 3px; /* From !test.html */
  }

  .library-controls button:hover {
    background-color: #1ED760; /* Slightly lighter green on hover */
    transform: translateY(-2px); /* Subtle lift effect from !test.html */
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.55); /* More pronounced shadow on hover from !test.html */
  }

  .library-controls .file-input-wrapper {
    position: relative;
    overflow: hidden;
    display: inline-flex; /* Use flex for vertical alignment of text */
    align-items: center;
    justify-content: center;
    background-color: var(--background-light);
    color: var(--text-color);
    border: 1px solid var(--border-color);
    padding: 16px 25px; /* From !test.html */
    min-height: 52px; /* From !test.html */
    border-radius: 28px; /* Pill-shaped from !test.html */
    cursor: pointer;
    font-size: 1.0em; /* From !test.html */
    font-weight: 500;
    transition: background-color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease; /* From !test.html */
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3); /* From !test.html */
  }

  .library-controls .file-input-wrapper:hover {
    background-color: #383838;
    border-color: #555555;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.45); /* More pronounced shadow on hover from !test.html */
  }
  
  .library-controls .file-input-wrapper:focus-within {
      outline: 3px solid rgba(var(--primary-color-rgb), 0.7); /* From !test.html */
      outline-offset: 3px; /* From !test.html */
  }

  .library-controls .file-input-wrapper input[type="file"] {
    position: absolute;
    left: 0;
    top: 0;
    opacity: 0;
    cursor: pointer;
    width: 100%;
    height: 100%;
  }

  .library-filter-nav {
    display: flex;
    gap: 15px; /* More gap from !test.html */
    flex-wrap: wrap;
    margin-bottom: 30px; /* More margin from !test.html */
  }

  .library-filter-nav button {
    background-color: var(--background-medium);
    color: var(--text-muted);
    border: 1px solid var(--border-color);
    padding: 12px 22px; /* Increased padding from !test.html */
    min-height: 44px; /* Increased min-height from !test.html */
    border-radius: 22px; /* Rounded filter buttons from !test.html */
    cursor: pointer;
    font-size: 0.95em; /* Slightly larger font from !test.html */
    font-weight: 500;
    transition: background-color 0.2s, border-color 0.2s, color 0.2s, transform 0.15s ease; /* Transition from !test.html */
  }
  
  .library-filter-nav button:focus {
      outline: 3px solid rgba(var(--primary-color-rgb), 0.7); /* From !test.html */
      outline-offset: 3px; /* From !test.html */
  }

  .library-filter-nav button:hover {
    background-color: var(--background-light);
    border-color: var(--text-muted);
    color: var(--text-color);
    transform: translateY(-1px); /* Subtle lift effect from !test.html */
  }

  .library-filter-nav button.active {
    background-color: var(--primary-color);
    color: var(--text-color);
    border-color: var(--primary-color);
    box-shadow: 0 2px 8px rgba(var(--primary-color-rgb), 0.4); /* From !test.html */
  }

  .library-list, .playlist-list {
    list-style: none;
    padding: 0;
    margin: 0;
    max-height: 450px; /* Default max height for scroll, increased from !test.html */
    overflow-y: auto;
    border: 1px solid var(--border-color);
    border-radius: 10px; /* Slightly more rounded from !test.html */
    background-color: var(--background-dark);
    box-shadow: inset 0 0 8px rgba(0,0,0,0.3); /* Inner shadow for list depth from !test.html */
  }

  .library-list li, .playlist-list li {
    padding: 18px 25px; /* More padding from !test.html */
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    transition: background-color 0.2s ease; /* From !test.html */
  }

  .library-list li:last-child, .playlist-list li:last-child {
    border-bottom: none;
  }

  .library-list li:hover, .playlist-list li:hover {
    background-color: #222222; /* Darker hover effect */
  }

  .library-list li.playing, .playlist-list li.playing { /* Apply playing style to both lists */
    background-color: rgba(var(--primary-color-rgb), 0.15); /* Subtle green highlight */
    border-left: 5px solid var(--primary-color); /* Thicker border from !test.html */
    padding-left: 20px; /* Adjust padding due to border from !test.html */
  }

  /* Styles for drag-and-drop */
  .playlist-list li.dragging {
      opacity: 0.5;
      border: 2px dashed var(--primary-color);
      background-color: var(--background-light);
  }
  .playlist-list li.drag-over {
      border-top: 2px solid var(--primary-color);
  }


  .track-info {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    gap: 6px; /* Small gap between title and artist, increased from !test.html */
  }

  .track-info strong {
    font-size: 1.18em; /* Slightly larger title from !test.html */
    font-weight: 600;
    color: var(--text-color);
    line-height: 1.3; /* Improved readability from !test.html */
  }

  .track-info span {
    font-size: 0.92em; /* Slightly smaller for artist/album from !test.html */
    color: var(--text-muted);
    line-height: 1.4; /* Improved readability from !test.html */
  }

  .playlist-actions button {
    background: none;
    border: none;
    color: var(--text-muted); /* Muted color for icons */
    font-size: 1.75em; /* Slightly larger icons for touch from !test.html */
    cursor: pointer;
    margin-left: 20px; /* More margin from !test.html */
    transition: color 0.2s ease, transform 0.15s ease, background-color 0.2s ease; /* Transition from !test.html */
    padding: 10px; /* Add padding for larger touch area from !test.html */
    border-radius: 50%; /* Make them circular buttons from !test.html */
  }
  
  .playlist-actions button:focus {
      outline: 3px solid rgba(var(--primary-color-rgb), 0.7); /* From !test.html */
      outline-offset: 3px; /* From !test.html */
  }

  .playlist-actions button:hover {
    color: var(--primary-color); /* Green on hover */
    background-color: rgba(var(--primary-color-rgb), 0.1); /* Subtle background on hover from !test.html */
    transform: scale(1.1);
  }

  .no-songs-message {
    text-align: center;
    padding: 40px; /* More padding from !test.html */
    color: var(--text-muted);
    font-size: 1.25em; /* Slightly larger font from !test.html */
    line-height: 1.5; /* From !test.html */
  }

  /* Player Controls */
  .player-controls-container {
    background-color: var(--background-light);
    padding: 30px; /* More padding from !test.html */
    border-top: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    gap: 25px; /* More gap from !test.html */
    box-shadow: 0 -8px 25px rgba(0,0,0,0.4); /* Shadow for player controls from !test.html */
  }

  .current-track-info {
    text-align: center;
  }

  .current-track-info h3 {
    margin: 0 0 10px 0; /* More margin from !test.html */
    color: var(--text-color);
    font-size: 1.6em; /* Larger title from !test.html */
    font-weight: 600;
    line-height: 1.3; /* From !test.html */
  }

  .current-track-info p {
    margin: 0;
    color: var(--text-muted);
    font-size: 1.05em; /* Slightly larger from !test.html */
    line-height: 1.4; /* From !test.html */
  }

  .progress-bar-container {
    width: 100%;
    height: 10px; /* Slightly thicker for easier tapping from !test.html */
    background-color: #404040; /* Darker background for progress bar */
    border-radius: 5px; /* From !test.html */
    cursor: pointer;
    position: relative;
    margin-bottom: 12px; /* Increased margin from !test.html */
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.5); /* Subtle inner shadow from !test.html */
  }

  .progress-bar {
    height: 100%;
    width: 0%;
    background: linear-gradient(to right, var(--primary-color), #68d391); /* Gradient for progress bar from !test.html */
    border-radius: 5px; /* From !test.html */
    transition: width 0.1s linear, background 0.2s ease; /* Added background transition from !test.html */
  }
  
  .progress-bar:hover {
      background: linear-gradient(to right, #1ED760, #73f0a0); /* Slightly lighter on hover from !test.html */
  }

  .time-info {
    display: flex;
    justify-content: space-between;
    font-size: 0.95em; /* Slightly larger from !test.html */
    color: var(--text-muted);
    margin-top: -5px;
    margin-bottom: 15px; /* Increased margin from !test.html */
  }

  .player-buttons {
    display: flex;
    justify-content: center;
    gap: 35px; /* More gap between buttons from !test.html */
    margin-bottom: 20px; /* Increased margin from !test.html */
  }

  .player-buttons button {
    background: none;
    border: none;
    color: var(--text-color); /* White icons */
    font-size: 2.8em; /* Larger player control icons from !test.html */
    cursor: pointer;
    transition: color 0.2s ease, transform 0.15s ease; /* Transition from !test.html */
    padding: 12px; /* Add padding for touch area from !test.html */
    border-radius: 50%; /* Make them circular buttons from !test.html */
  }
  
  .player-buttons button:focus {
      outline: 3px solid rgba(var(--primary-color-rgb), 0.7); /* From !test.html */
      outline-offset: 3px; /* From !test.html */
  }

  .player-buttons button:hover {
    color: var(--primary-color); /* Green on hover */
    transform: scale(1.15); /* More pronounced lift from !test.html */
  }

  /* Repeat button specific styling */
  .player-buttons button.repeat-one {
      color: var(--primary-color);
      transform: scale(1.1);
      border: 1px solid var(--primary-color);
  }
  .player-buttons button.repeat-all {
      color: var(--primary-color);
      transform: scale(1.1);
      border: 1px solid var(--primary-color);
  }


  .volume-controls {
    display: flex;
    align-items: center;
    gap: 18px; /* More gap from !test.html */
    justify-content: center;
  }

  .volume-controls input[type="range"] {
    flex-grow: 1;
    max-width: 280px; /* Slightly wider slider from !test.html */
    -webkit-appearance: none;
    background: #404040; /* Darker background for slider track */
    border-radius: 5px;
    height: 12px; /* Thicker track from !test.html */
    outline: none;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.4); /* Inner shadow for track from !test.html */
  }

  .volume-controls input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 24px; /* Larger thumb for touch from !test.html */
    height: 24px; /* Larger thumb for touch from !test.html */
    background: var(--primary-color); /* Spotify Green thumb */
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5); /* Enhanced shadow from !test.html */
    transition: background-color 0.2s ease, transform 0.15s ease, box-shadow 0.2s ease; /* Transition from !test.html */
  }

  .volume-controls input[type="range"]::-webkit-slider-thumb:hover {
      background-color: #1ED760;
      transform: scale(1.1);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.6); /* From !test.html */
  }
  
  .volume-controls input[type="range"]:focus::-webkit-slider-thumb {
      outline: 3px solid rgba(var(--primary-color-rgb), 0.7); /* From !test.html */
      outline-offset: 3px; /* Offset from the thumb from !test.html */
  }

  .volume-controls input[type="range"]::-moz-range-thumb {
    width: 24px; /* Larger thumb for touch from !test.html */
    height: 24px; /* Larger thumb for touch from !test.html */
    background: var(--primary-color); /* Spotify Green thumb */
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5); /* Enhanced shadow from !test.html */
    transition: background-color 0.2s ease, transform 0.15s ease, box-shadow 0.2s ease; /* Transition from !test.html */
  }

  .volume-controls input[type="range"]::-moz-range-thumb:hover {
      background-color: #1ED760;
      transform: scale(1.1);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.6); /* From !test.html */
  }
  
  .volume-controls input[type="range"]:focus::-moz-range-thumb {
      outline: 3px solid rgba(var(--primary-color-rgb), 0.7); /* From !test.html */
      outline-offset: 3px; /* From !test.html */
  }

  /* Stream URL input */
  .stream-input-group, .youtube-playlist-input-group {
    display: flex;
    gap: 20px; /* More gap from !test.html */
    margin-top: 25px; /* More margin from !test.html */
    flex-wrap: wrap;
  }

  .stream-input-group input[type="text"],
  .youtube-playlist-input-group input[type="text"] {
    flex-grow: 1;
    padding: 16px 20px; /* Increased padding from !test.html */
    min-height: 52px; /* Consistent height from !test.html */
    border: 2px solid var(--border-color); /* Thicker border for validation state from !test.html */
    border-radius: 10px; /* Slightly rounded corners from !test.html */
    background-color: #333333; /* Darker input background */
    color: var(--text-color);
    font-size: 1.0em; /* Slightly larger font from !test.html */
    transition: border-color 0.2s ease, box-shadow 0.2s ease; /* From !test.html */
  }
  
  /* Input validation styles */
  .stream-input-group input[type="text"].valid,
  .youtube-playlist-input-group input[type="text"].valid {
      border-color: var(--success-color);
      box-shadow: 0 0 0 3px rgba(var(--primary-color-rgb), 0.3); /* From !test.html */
  }
  .stream-input-group input[type="text"].invalid,
  .youtube-playlist-input-group input[type="text"].invalid {
      border-color: var(--error-color);
      box-shadow: 0 0 0 3px rgba(244, 67, 54, 0.3);
  }

  .stream-input-group input[type="text"]:focus,
  .youtube-playlist-input-group input[type="text"]:focus {
      outline: none;
      border-color: var(--primary-color); /* Green border on focus */
      box-shadow: 0 0 0 3px rgba(var(--primary-color-rgb), 0.5); /* Stronger focus shadow from !test.html */
  }

  .stream-input-group button,
  .youtube-playlist-input-group button {
    background-color: var(--primary-color);
    color: white;
    border: none;
    padding: 16px 25px; /* Increased padding from !test.html */
    min-height: 52px; /* Consistent height from !test.html */
    border-radius: 28px; /* Pill-shaped buttons from !test.html */
    cursor: pointer;
    font-size: 1.0em;
    font-weight: 600;
    transition: background-color 0.2s ease, transform 0.15s ease, box-shadow 0.2s ease; /* From !test.html */
    white-space: nowrap;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4); /* From !test.html */
  }

  .stream-input-group button:hover,
  .youtube-playlist-input-group button:hover {
    background-color: #1ED760;
    transform: translateY(-2px); /* From !test.html */
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.55); /* From !test.html */
  }
  
  .stream-input-group button:focus,
  .youtube-playlist-input-group button:focus {
      outline: 3px solid rgba(var(--primary-color-rgb), 0.7); /* From !test.html */
      outline-offset: 3px; /* From !test.html */
  }

  /* Visualizer */
  #visualizer {
    background-color: var(--background-dark);
    border-radius: 10px; /* From !test.html */
    margin-bottom: 25px; /* Increased margin from !test.html */
    width: 100%;
    height: 150px; /* Taller visualizer from !test.html */
    border: 1px solid var(--border-color);
    box-shadow: inset 0 0 8px rgba(0,0,0,0.4); /* Inner shadow for depth from !test.html */
  }

  /* Scrollbar Styling (for Webkit browsers like Chrome/Safari) */
  ::-webkit-scrollbar {
    width: 10px; /* Wider scrollbar from !test.html */
    height: 10px;
  }

  ::-webkit-scrollbar-track {
    background: var(--background-dark);
    border-radius: 10px;
  }

  ::-webkit-scrollbar-thumb {
    background: #666; /* Slightly lighter thumb from !test.html */
    border-radius: 10px;
  }

  ::-webkit-scrollbar-thumb:hover {
    background: #888; /* Even lighter on hover from !test.html */
  }

  /* Playlist controls styling */
  .playlist-controls {
    display: flex;
    justify-content: flex-start; /* Align to start */
    gap: 15px; /* More gap */
    margin-bottom: 25px; /* Space above playlist */
    flex-wrap: wrap; /* Allow wrapping on smaller screens */
  }

  .playlist-controls button {
    background-color: var(--background-light); /* Different background for differentiation */
    color: var(--text-color);
    border: 1px solid var(--border-color);
    padding: 14px 20px;
    min-height: 48px;
    border-radius: 25px;
    cursor: pointer;
    font-size: 0.95em;
    font-weight: 600;
    transition: background-color 0.2s ease, transform 0.1s ease, border-color 0.2s ease;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
  }

  .playlist-controls button:hover {
    background-color: #383838;
    border-color: #555555;
    transform: translateY(-1px);
  }

  /* Loading Indicator */
  .loading-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      z-index: 10;
      display: none; /* Hidden by default */
  }
  .loading-indicator.show {
      display: block;
  }


  @media (max-width: 600px) {
    body {
      padding: 10px;
      padding-bottom: 30px; /* Adjusted padding for mobile from !test.html */
    }

    .container {
      max-width: 100%;
      border-radius: 0;
    }

    header {
      flex-direction: column;
      text-align: center;
      padding: 20px 15px; /* Adjusted padding from !test.html */
    }

    header h1 {
        font-size: 1.8em; /* Adjusted font size for mobile from !test.html */
    }

    main {
        padding: 20px 15px; /* Adjusted padding from !test.html */
    }

    .library-controls, .stream-input-group, .youtube-playlist-input-group, .playlist-controls {
      flex-direction: column;
      gap: 15px; /* Adjusted gap from !test.html */
      margin-bottom: 20px; /* Adjusted margin from !test.html */
    }

    .library-controls .file-input-wrapper,
    .stream-input-group input[type="text"],
    .stream-input-group button,
    .youtube-playlist-input-group input[type="text"],
    .youtube-playlist-input-group button,
    .playlist-controls button {
      width: 100%;
      font-size: 0.95em; /* Adjusted font size from !test.html */
      padding: 14px 18px; /* Adjusted padding from !test.html */
      min-height: 48px; /* Adjusted min-height from !test.html */
    }

    .library-filter-nav {
      justify-content: center;
      gap: 10px; /* Adjusted gap from !test.html */
      margin-bottom: 20px; /* Adjusted margin from !test.html */
    }

    .library-filter-nav button {
        padding: 10px 15px; /* Adjusted padding from !test.html */
        min-height: 40px; /* Adjusted min-height from !test.html */
        font-size: 0.9em; /* Adjusted font size from !test.html */
    }

    .library-filter-nav button.active {
      box-shadow: 0 1px 4px rgba(var(--primary-color-rgb), 0.3); /* Smaller shadow on mobile from !test.html */
    }

    .library-list, .playlist-list {
        max-height: 40vh; /* Adjusted viewport height for lists on smaller screens from !test.html */
        border-radius: 8px; /* Adjusted border-radius from !test.html */
    }

    .library-list li, .playlist-list li {
        padding: 15px 20px; /* Adjusted padding from !test.html */
    }

    .track-info strong {
        font-size: 1.05em; /* Adjusted font size from !test.html */
    }

    .track-info span {
        font-size: 0.85em; /* Adjusted font size from !test.html */
    }

    .playlist-actions button {
        font-size: 1.5em; /* Adjusted font size from !test.html */
        margin-left: 10px; /* Adjusted margin from !test.html */
        padding: 8px; /* Adjusted padding from !test.html */
    }

    .no-songs-message {
        padding: 25px; /* Adjusted padding from !test.html */
        font-size: 1.1em; /* Adjusted font size from !test.html */
    }

    .player-controls-container {
        padding: 20px 15px; /* Adjusted padding from !test.html */
        gap: 20px; /* Adjusted gap from !test.html */
    }

    .current-track-info h3 {
        font-size: 1.2em; /* Adjusted font size from !test.html */
        margin-bottom: 8px; /* Adjusted margin from !test.html */
    }

    .current-track-info p {
        font-size: 0.9em; /* Adjusted font size from !test.html */
    }

    .progress-bar-container {
        height: 8px; /* Adjusted height from !test.html */
        border-radius: 4px; /* Adjusted border-radius from !test.html */
    }

    .progress-bar {
        border-radius: 4px; /* Adjusted border-radius from !test.html */
    }

    .time-info {
        font-size: 0.85em; /* Adjusted font size from !test.html */
    }

    .player-buttons {
        gap: 25px; /* Adjusted gap from !test.html */
    }

    .player-buttons button {
        font-size: 2.2em; /* Adjusted font size from !test.html */
        padding: 8px; /* Adjusted padding from !test.html */
    }

    .volume-controls {
        flex-direction: column;
        gap: 12px; /* Adjusted gap from !test.html */
    }

    .volume-controls input[type="range"] {
      width: 100%;
      max-width: 100%;
      height: 8px;
    }

    .volume-controls input[type="range"]::-webkit-slider-thumb,
    .volume-controls input[type="range"]::-moz-range-thumb {
        width: 20px; /* Adjusted size from !test.html */
        height: 20px; /* Adjusted size from !test.html */
    }

    #visualizer {
        height: 120px; /* Slightly smaller visualizer on mobile from !test.html */
    }
  }
</style>
</head>
<body>
  <div class="ui-message" id="ui-message"></div>
  <div class="loading-indicator" id="loading-indicator">Loading...</div>

  <div class="container">
    <header>
      <h1>Advanced Music Player</h1>
      <div class="settings">
        </div>
    </header>

    <nav class="tabs">
      <div class="tab-button active" id="playlist-tab-btn">Playlist</div>
      <div class="tab-button" id="library-tab-btn">Library</div>
    </nav>

    <main>
      <div class="tab-content active" id="playlist-tab">
        <div class="playlist-controls">
          <button id="save-playlist-btn">Save Current Playlist</button>
          <button id="load-playlist-btn">Load Saved Playlist</button>
          <button id="clear-playlist-btn">Clear Playlist</button>
          <button id="shuffle-playlist-btn">Shuffle Playlist</button>
        </div>
        <ul class="playlist-list" id="playlist-list">
          </ul>
        <p id="no-playlist-message" class="no-songs-message" style="display: none;">Your playlist is empty. Add some music from the Library or by streaming!</p>
      </div>

      <div class="tab-content" id="library-tab">
        <div class="library-controls">
          <div class="file-input-wrapper">
            <input type="file" id="add-music-file-input" accept="audio/*" multiple />
            <span>Add Local Music</span>
          </div>
          <input type="text" id="youtube-url-input" placeholder="Paste YouTube Video URL" />
          <button id="play-youtube-btn">Play YouTube Audio</button>
        </div>

        <div class="stream-input-group">
            <input type="text" id="stream-url-input" placeholder="Enter MP3/AAC stream URL" />
            <button id="play-stream-btn">Play Stream</button>
        </div>

        <div class="youtube-playlist-input-group stream-input-group">
            <input type="text" id="youtube-playlist-url-input" placeholder="Enter YouTube Playlist URL" />
            <button id="add-youtube-playlist-btn">Add YouTube Playlist</button>
        </div>

        <nav class="library-filter-nav">
          <button id="view-all-songs-btn">All Songs</button>
          <button id="view-albums-btn">Albums</button>
          <button id="view-artists-btn">Artists</button>
          <button id="view-genres-btn">Genres</button>
          <button id="clear-filter-btn">Clear Filter</button>
        </nav>
        <ul class="library-list" id="library-list">
          </ul>
        <p id="no-library-message" class="no-songs-message" style="display: none;">Your music library is empty. Add some local files!</p>
      </div>
    </main>

    <div class="player-controls-container">
      <canvas id="visualizer"></canvas>

      <div class="current-track-info">
        <h3 id="current-track-title">No track playing</h3>
        <p id="current-track-artist">Artist - Album</p>
      </div>

      <div class="progress-bar-container" id="progress-bar-container">
        <div class="progress-bar" id="progress-bar"></div>
      </div>
      <div class="time-info">
        <span id="current-time">0:00</span>
        <span id="duration">0:00</span>
      </div>

      <div class="player-buttons">
        <button id="prev-btn">‚èÆÔ∏è</button>
        <button id="play-pause-btn">‚ñ∂Ô∏è</button>
        <button id="next-btn">‚è≠Ô∏è</button>
        <button id="repeat-btn" title="Repeat Off">üîÅ</button>
        <button id="shuffle-btn" title="Shuffle Queue">üîÄ</button>
      </div>

      <div class="volume-controls">
        <span>üîá</span>
        <input type="range" id="volume-slider" min="0" max="100" value="75" />
        <span>üîä</span>
      </div>
    </div>
  </div>

  <div id="youtube-player" style="display: none;"></div>

  <script src="https://www.youtube.com/iframe_api" async></script>

  <script>
    'use strict'; // Enable strict mode for better error checking

    (function() {
      // --- Security: YouTube Data API Key ---
      // IMPORTANT: The API key has been removed from the source code for security.
      // In a real-world application, you should NEVER expose your API key on the client-side.
      // Instead, create a backend server (a "proxy") that securely stores the key
      // and makes requests to the YouTube API on behalf of your app.
      // For development, you can paste your key here, but do not commit it to version control.
      const YOUTUBE_API_KEY = 'AIzaSyDBQ9OjY2XW8DY7-WpPb6Q2LURnWCzkoAY'; // <--- REPLACE THIS LINE WITH YOUR ACTUAL KEY

      // --- IndexedDB Setup ---
      const IDB_DATABASE_NAME = 'music-db';
      const IDB_TRACKS_STORE_NAME = 'tracks'; // Renamed for clarity
      const IDB_PLAYLISTS_STORE_NAME = 'playlists'; // New constant
      let db; // Global IndexedDB database instance

      /**
       * Opens the IndexedDB database.
       * Creates the object store if it doesn't exist.
       * @returns {Promise<IDBDatabase>} A promise that resolves with the database instance.
       */
      function openIndexedDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(IDB_DATABASE_NAME, 1);

          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(IDB_TRACKS_STORE_NAME)) {
              db.createObjectStore(IDB_TRACKS_STORE_NAME, { keyPath: 'id', autoIncrement: true });
            }
            // NEW: Create playlists store
            if (!db.objectStoreNames.contains(IDB_PLAYLISTS_STORE_NAME)) {
              db.createObjectStore(IDB_PLAYLISTS_STORE_NAME, { keyPath: 'name' }); // Use playlist name as key
            }
          };

          request.onsuccess = (event) => {
            db = event.target.result;
            resolve(db);
          };

          request.onerror = (event) => {
            console.error('IndexedDB error:', event.target.error);
            reject(event.target.error);
          };
        });
      }

      // --- UI Feedback ---
      const uiMessageElement = document.getElementById('ui-message');
      const loadingIndicator = document.getElementById('loading-indicator'); // New loading indicator element
      let messageTimeout;

      /**
       * Displays a message to the user in the UI.
       * @param {string} message The text to display.
       * @param {string} type The type of message ('success', 'error', 'info').
       * @param {number} duration The duration in milliseconds to show the message.
       */
      function showUIMessage(message, type = 'info', duration = 3000) {
        clearTimeout(messageTimeout); // Clear any existing message timeout
        uiMessageElement.textContent = message;
        uiMessageElement.className = `ui-message ${type} show`; // Add type and show classes
        
        messageTimeout = setTimeout(() => {
          uiMessageElement.classList.remove('show');
        }, duration);
      }

      /**
       * Shows or hides the loading indicator.
       * @param {boolean} show True to show, false to hide.
       */
      function showLoadingIndicator(show) {
          loadingIndicator.classList.toggle('show', show);
      }
      
      // --- Audio Context and Visualizer ---
      let audioContext;
      let analyser;
      let sourceNode; // The AudioNode connected to the analyser (MediaElementSource or YouTube source)
      let visualizerCanvas;
      let visualizerCtx;
      let bufferLength;
      let dataArray;

      /**
       * Sets up the visualizer canvas and context.
       */
      function setupVisualizer() {
        visualizerCanvas = document.getElementById('visualizer');
        visualizerCtx = visualizerCanvas.getContext('2d');
        // Set canvas resolution to match its displayed size
        visualizerCanvas.width = visualizerCanvas.offsetWidth;
        visualizerCanvas.height = visualizerCanvas.offsetHeight;

        // Create AudioContext only on first user gesture to comply with browser autoplay policies
        document.addEventListener('click', initAudioContext, { once: true });
        document.addEventListener('keydown', initAudioContext, { once: true });
      }

      /**
       * Initializes the AudioContext and AnalyserNode.
       * This function is called on the first user interaction.
       */
      function initAudioContext() {
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 256; // Fast Fourier Transform size (number of samples in frequency data)
          bufferLength = analyser.frequencyBinCount; // Number of data points (half of fftSize)
          dataArray = new Uint8Array(bufferLength); // Array to hold frequency data (byte values)

          // Connect analyser to the audio output (speakers)
          analyser.connect(audioContext.destination);
          drawVisualizer(); // Start drawing once context is ready
        }
      }

      /**
       * Connects an audio source node to the analyser for visualization.
       * Disconnects any previously connected source.
       * @param {AudioNode} audioNode The audio source node to connect (e.g., MediaElementSource).
       */
      function connectSourceToVisualizer(audioNode) {
        // Disconnect old source if it exists to prevent multiple connections
        if (sourceNode) {
          sourceNode.disconnect(analyser);
        }
        sourceNode = audioNode;
        sourceNode.connect(analyser);
      }

      /**
       * Draws the audio visualization on the canvas.
       * This function is called in a loop using requestAnimationFrame.
       */
      function drawVisualizer() {
        requestAnimationFrame(drawVisualizer); // Loop this function for continuous animation

        if (!analyser || !dataArray) return; // Ensure analyser is initialized

        analyser.getByteFrequencyData(dataArray); // Get frequency data from the analyser

        visualizerCtx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height); // Clear canvas for new frame

        const barWidth = (visualizerCanvas.width / bufferLength) * 2.5; // Calculate bar width based on canvas width and data points
        let x = 0;

        for (let i = 0; i < bufferLength; i++) {
          const barHeight = dataArray[i]; // Get bar height from frequency data (0-255)

          // Create a gradient for the bars
          const gradient = visualizerCtx.createLinearGradient(0, visualizerCanvas.height, 0, visualizerCanvas.height - barHeight);
          gradient.addColorStop(0, 'var(--primary-color)');
          gradient.addColorStop(1, '#68d391'); // Lighter green

          visualizerCtx.fillStyle = gradient;
          visualizerCtx.fillRect(x, visualizerCanvas.height - barHeight, barWidth, barHeight);

          x += barWidth + 1; // Move to the right for the next bar, with a small gap
        }
      }

      // --- Track Management (Local Files, Streams, and YouTube) ---
      let library = []; // Stores all tracks added by the user (primarily local files)
      let playlist = []; // The currently active playlist, can contain local, stream, or YouTube tracks
      let currentTrackIndex = -1; // Index of the currently playing track in the playlist
      let audio = new Audio(); // HTML5 Audio element for local files and direct streams
      let isPlaying = false;
      let currentTrackType = 'local'; // 'local', 'stream', or 'youtube'
      let repeatMode = 'off'; // 'off', 'one', 'all'
      let originalPlaylistOrder = []; // To store playlist order before shuffle
      let notificationPermission = 'default'; // 'default', 'granted', 'denied'


      // --- DOM Elements ---
      const addMusicFileInput = document.getElementById('add-music-file-input');
      const streamUrlInput = document.getElementById('stream-url-input');
      const playStreamBtn = document.getElementById('play-stream-btn');
      const playlistList = document.getElementById('playlist-list');
      const libraryList = document.getElementById('library-list');
      const noPlaylistMessage = document.getElementById('no-playlist-message');
      const noLibraryMessage = document.getElementById('no-library-message');

      const playPauseBtn = document.getElementById('play-pause-btn');
      const prevBtn = document.getElementById('prev-btn');
      const nextBtn = document.getElementById('next-btn');
      const volumeSlider = document.getElementById('volume-slider');
      const progressBar = document.getElementById('progress-bar');
      const progressBarContainer = document.getElementById('progress-bar-container');
      const currentTimeSpan = document.getElementById('current-time');
      const durationSpan = document.getElementById('duration');
      const currentTrackTitle = document.getElementById('current-track-title');
      const currentTrackArtist = document.getElementById('current-track-artist');

      // Tab Buttons
      const playlistTabBtn = document.getElementById('playlist-tab-btn');
      const libraryTabBtn = document.getElementById('library-tab-btn');
      const playlistTab = document.getElementById('playlist-tab');
      const libraryTab = document.getElementById('library-tab');

      // Library Filter Buttons
      const viewAllSongsBtn = document.getElementById('view-all-songs-btn');
      const viewAlbumsBtn = document.getElementById('view-albums-btn');
      const viewArtistsBtn = document.getElementById('view-artists-btn');
      const viewGenresBtn = document.getElementById('view-genres-btn');
      const clearFilterBtn = document.getElementById('clear-filter-btn');

      // YouTube Integration Elements
      const youtubeUrlInput = document.getElementById('youtube-url-input');
      const playYoutubeBtn = document.getElementById('play-youtube-btn');
      let youtubePlayer; // Variable to hold the YouTube player instance

      // New YouTube Playlist Elements
      const youtubePlaylistUrlInput = document.getElementById('youtube-playlist-url-input');
      const addYoutubePlaylistBtn = document.getElementById('add-youtube-playlist-btn');
      
      // New Playlist Saving/Loading Buttons
      const savePlaylistBtn = document.getElementById('save-playlist-btn');
      const loadPlaylistBtn = document.getElementById('load-playlist-btn');
      const clearPlaylistBtn = document.getElementById('clear-playlist-btn'); // Added clear playlist button
      const shufflePlaylistBtn = document.getElementById('shuffle-playlist-btn'); // Added shuffle playlist button
      const repeatBtn = document.getElementById('repeat-btn'); // Added repeat button


      // --- YouTube IFrame Player API Functions ---
      /**
       * This function is called by the YouTube API when it's fully loaded.
       * Initializes the YouTube player.
       */
      window.onYouTubeIframeAPIReady = function() {
          console.log("YouTube IFrame API is Ready.");
          youtubePlayer = new YT.Player('youtube-player', {
              height: '0', // Make the player invisible
              width: '0',  // Make the player invisible
              videoId: '', // No video ID initially
              playerVars: {
                  'autoplay': 1,
                  'controls': 0,
                  'disablekb': 1,
                  'modestbranding': 1,
                  'rel': 0,
                  'enablejsapi': 1,
                  'html5': 1 // Prefer HTML5 player over Flash
              },
              events: {
                  'onReady': onPlayerReady,
                  'onStateChange': onPlayerStateChange,
                  'onError': onPlayerError
              }
          });
      };

      /**
       * Callback function when the YouTube player is ready.
       * @param {Object} event The YouTube player event object.
       */
      function onPlayerReady(event) {
          console.log('YouTube player ready.');
          if (youtubePlayer) {
              youtubePlayer.setVolume(volumeSlider.value);
          }
      }
      
      /**
       * Callback for YouTube player errors.
       * @param {object} event The error event.
       */
      function onPlayerError(event) {
          console.error('YouTube Player Error:', event.data);
          showUIMessage(`YouTube player error: ${event.data}`, 'error');
          showLoadingIndicator(false); // Hide loading indicator on error
          playNextTrack(); // Try to play the next track
      }

      /**
       * Callback function when the YouTube player's state changes.
       * Handles play/pause, ended, and buffering states.
       * @param {Object} event The YouTube player event object.
       */
      function onPlayerStateChange(event) {
          const state = event.data;
          switch (state) {
              case YT.PlayerState.PLAYING:
                  isPlaying = true;
                  updatePlayPauseButton();
                  updateMediaSession();
                  showLoadingIndicator(false); // Hide loading indicator when playing
                  sendNowPlayingNotification(); // Send notification
                  break;
              case YT.PlayerState.PAUSED:
                  isPlaying = false;
                  updatePlayPauseButton();
                  break;
              case YT.PlayerState.ENDED:
                  handleTrackEnded(); // Use the common track ended handler
                  break;
              case YT.PlayerState.BUFFERING:
                  showLoadingIndicator(true); // Show loading indicator when buffering
                  break;
              case YT.PlayerState.CUED: // When video is cued but not yet playing
                  showLoadingIndicator(true);
                  break;
          }
          updateProgressBarAndTimer(); // Update UI for YouTube playback
      }

      /**
       * Plays a specific YouTube video by its ID.
       * @param {string} videoId The ID of the YouTube video.
       */
      function playYouTubeAudio(videoId) {
          if (!youtubePlayer || typeof youtubePlayer.loadVideoById !== 'function') {
              showUIMessage("YouTube player is not ready yet.", 'error');
              return;
          }
          if (!audio.paused) audio.pause();
          
          currentTrackType = 'youtube';
          youtubePlayer.loadVideoById(videoId);
          isPlaying = true;
          updatePlayPauseButton();
          updateCurrentTrackInfo();
          showLoadingIndicator(true); // Show loading indicator immediately
      }

      /**
       * Extracts the video ID from a YouTube video URL.
       * @param {string} url The YouTube video URL.
       * @returns {string|null} The video ID or null if not found.
       */
      function extractYouTubeVideoId(url) {
          const regExp = /(?:youtube\.com\/(?:[^\/]+\/.+\/|\/(?:v|e(?:mbed)?)\/|watch\?v=)|youtu\.be\/)([^&?#]{11})/;
          const match = url.match(regExp);
          return (match && match[1]) ? match[1] : null;
      }

      /**
       * Extracts the playlist ID from a YouTube playlist URL.
       * @param {string} url The YouTube playlist URL.
       * @returns {string|null} The playlist ID or null if not found.
       */
      function extractYouTubePlaylistId(url) {
          const regExp = /[?&]list=([^&#]+)/;
          const match = url.match(regExp);
          return (match && match[1]) ? match[1] : null;
      }

      /**
       * Fetches and adds all videos from a YouTube playlist to the application's playlist.
       * @param {string} playlistId The ID of the YouTube playlist.
       */
      async function addYouTubePlaylist(playlistId) {
          if (!YOUTUBE_API_KEY || YOUTUBE_API_KEY === 'AIzaSyDBQ9OjY2XW8DY7-WpPb6Q2LURnWCzkoAY') {
              showUIMessage("YouTube API Key is not configured. Please replace the placeholder.", 'error', 7000);
              return;
          }

          let nextPageToken = '';
          let playlistTitle = 'YouTube Playlist';
          let videosAdded = 0;
          showUIMessage('Fetching playlist...', 'info', 10000);
          showLoadingIndicator(true); // Show loading indicator for network request

          try {
              // Fetch playlist details (title)
              const detailsUrl = `https://www.googleapis.com/youtube/v3/playlists?part=snippet&id=${playlistId}&key=${YOUTUBE_API_KEY}`;
              const detailsResponse = await fetch(detailsUrl);
              if (!detailsResponse.ok) throw new Error(`HTTP error! status: ${detailsResponse.status}`);
              const detailsData = await detailsResponse.json();
              if (detailsData.items && detailsData.items.length > 0) {
                  playlistTitle = detailsData.items[0].snippet.title;
              }

              // Fetch playlist items (videos)
              do {
                  const itemsUrl = `https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&maxResults=50&playlistId=${playlistId}&key=${YOUTUBE_API_KEY}${nextPageToken ? `&pageToken=${nextPageToken}` : ''}`;
                  const response = await fetch(itemsUrl);
                  if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                  const data = await response.json();

                  if (data.items) {
                      data.items.forEach(item => {
                          const { videoId } = item.snippet.resourceId;
                          const { title, channelTitle } = item.snippet;
                          if (videoId && title !== 'Private video' && title !== 'Deleted video') {
                              const youtubeTrack = {
                                  id: videoId,
                                  url: `https://www.youtube.com/watch?v=${videoId}`, // Full YouTube video URL
                                  videoId: videoId,
                                  type: 'youtube',
                                  title: title,
                                  artist: channelTitle,
                                  album: playlistTitle,
                                  genre: 'Video'
                              };
                              // Check for duplicates before adding
                              if (!playlist.some(t => t.id === videoId && t.type === 'youtube')) {
                                  playlist.push(youtubeTrack);
                                  videosAdded++;
                              }
                          }
                      });
                      nextPageToken = data.nextPageToken;
                  } else {
                      nextPageToken = null;
                  }
              } while (nextPageToken);

              renderPlaylist();
              showUIMessage(`Added ${videosAdded} videos from "${playlistTitle}"`, 'success');
              showTab('playlist-tab');

          } catch (error) {
              console.error("Error fetching YouTube playlist:", error);
              showUIMessage('Failed to fetch playlist. Check URL or API key.', 'error', 5000);
          } finally {
              showLoadingIndicator(false); // Hide loading indicator after fetch
          }
      }


      // --- General Player Control Functions (adapted for YouTube) ---
      /**
       * Plays the currently selected track in the playlist.
       * Handles local, stream, and YouTube track types.
       */
      function playCurrentTrack() {
        if (playlist.length === 0 || currentTrackIndex === -1) {
            pauseCurrentTrack();
            updateCurrentTrackInfo(); // Update UI to show "No track playing"
            showLoadingIndicator(false);
            return;
        }

        const track = playlist[currentTrackIndex];

        // Pause any currently playing audio/YouTube video before switching
        if (!audio.paused) audio.pause();
        if (youtubePlayer && typeof youtubePlayer.pauseVideo === 'function' && youtubePlayer.getPlayerState() === 1) {
            youtubePlayer.pauseVideo();
        }

        currentTrackType = track.type;
        showLoadingIndicator(true); // Show loading indicator before playing new track

        if (track.type === 'youtube') {
            playYouTubeAudio(track.videoId);
        } else {
            // This handles both 'local' and 'stream' types
            audio.src = track.type === 'local' ? URL.createObjectURL(track.file) : track.url;
            audio.play()
                .then(() => {
                    isPlaying = true;
                    updatePlayPauseButton();
                    updateCurrentTrackInfo();
                    renderPlaylist();
                    updateMediaSession(); // Update media session when track changes
                    showLoadingIndicator(false); // Hide loading indicator when playing
                    sendNowPlayingNotification(); // Send notification
                })
                .catch(e => {
                    console.error("Error playing audio:", e);
                    showUIMessage(`Could not play track: ${track.title}`, 'error');
                    showLoadingIndicator(false); // Hide loading indicator on error
                });
            if (audioContext) {
                // This requires a Cross-Origin header for streams, may not always work
                try {
                    if (!sourceNode || sourceNode.mediaElement !== audio) {
                        connectSourceToVisualizer(audioContext.createMediaElementSource(audio));
                    }
                } catch (e) {
                    console.warn("Could not connect audio to visualizer (CORS issue with stream?).", e);
                }
            }
        }

        renderPlaylist(); // Re-render to highlight playing track
      }

      /**
       * Pauses the currently playing track (local, stream, or YouTube).
       */
      function pauseCurrentTrack() {
        if (currentTrackType === 'youtube' && youtubePlayer && typeof youtubePlayer.pauseVideo === 'function') {
            youtubePlayer.pauseVideo();
        } else {
            audio.pause();
        }
        isPlaying = false;
        updatePlayPauseButton();
        showLoadingIndicator(false); // Hide loading indicator on pause
      }

      /**
       * Toggles play/pause for the current track.
       */
      function togglePlayPause() {
        if (currentTrackIndex === -1 && playlist.length > 0) {
            currentTrackIndex = 0;
        }
        
        if (isPlaying) {
          pauseCurrentTrack();
        } else {
          playCurrentTrack();
        }
      }

      /**
       * Handles logic when a track ends.
       */
      function handleTrackEnded() {
          if (repeatMode === 'one') {
              playCurrentTrack(); // Replay the current track
          } else if (repeatMode === 'all') {
              playNextTrack(); // Play next, will loop to start if at end
          } else {
              // No repeat, move to next or stop
              if (currentTrackIndex < playlist.length - 1) {
                  playNextTrack();
              } else {
                  // End of playlist
                  pauseCurrentTrack();
                  if (currentTrackType === 'youtube' && youtubePlayer) youtubePlayer.stopVideo();
                  currentTrackIndex = -1;
                  updateCurrentTrackInfo();
                  renderPlaylist();
                  showUIMessage('Playlist finished.', 'info');
              }
          }
      }

      /**
       * Plays the next track in the playlist.
       */
      function playNextTrack() {
        if (playlist.length === 0) return;
        currentTrackIndex = (currentTrackIndex + 1) % playlist.length;
        playCurrentTrack();
      }

      /**
       * Plays the previous track in the playlist.
       */
      function playPrevTrack() {
        if (playlist.length === 0) return;
        currentTrackIndex = (currentTrackIndex - 1 + playlist.length) % playlist.length;
        playCurrentTrack();
      }

      /**
       * Toggles repeat mode: off -> one -> all -> off.
       */
      function toggleRepeatMode() {
          if (repeatMode === 'off') {
              repeatMode = 'one';
              repeatBtn.textContent = ' '; // Repeat one icon
              repeatBtn.title = 'Repeat One';
              repeatBtn.classList.add('repeat-one');
              repeatBtn.classList.remove('repeat-all');
              showUIMessage('Repeat: One Track', 'info', 1500);
          } else if (repeatMode === 'one') {
              repeatMode = 'all';
              repeatBtn.textContent = 'üîÅ'; // Repeat all icon
              repeatBtn.title = 'Repeat All';
              repeatBtn.classList.remove('repeat-one');
              repeatBtn.classList.add('repeat-all');
              showUIMessage('Repeat: All Tracks', 'info', 1500);
          } else {
              repeatMode = 'off';
              repeatBtn.textContent = 'üîÅ'; // Repeat off icon (default)
              repeatBtn.title = 'Repeat Off';
              repeatBtn.classList.remove('repeat-one', 'repeat-all');
              showUIMessage('Repeat: Off', 'info', 1500);
          }
      }

      /**
       * Shuffles the current playlist.
       */
      function shufflePlaylist() {
          if (playlist.length <= 1) {
              showUIMessage('Not enough tracks to shuffle.', 'info');
              return;
          }
          // Save original order before shuffling
          originalPlaylistOrder = [...playlist];

          for (let i = playlist.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [playlist[i], playlist[j]] = [playlist[j], playlist[i]];
          }
          
          // If a track was playing, find its new index
          if (currentTrackIndex !== -1) {
              const currentTrack = playlist[currentTrackIndex]; // Get the track object
              currentTrackIndex = playlist.findIndex(track => track.id === currentTrack.id && track.type === currentTrack.type);
          }

          renderPlaylist();
          showUIMessage('Playlist shuffled!', 'success');
      }

      /**
       * Updates the play/pause button icon based on the playing state.
       */
      function updatePlayPauseButton() {
        playPauseBtn.textContent = isPlaying ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è';
      }

      /**
       * Updates the displayed title and artist of the current track.
       */
      function updateCurrentTrackInfo() {
        if (currentTrackIndex > -1 && playlist[currentTrackIndex]) {
          const track = playlist[currentTrackIndex];
          currentTrackTitle.textContent = track.title || 'Unknown Title';
          currentTrackArtist.textContent = track.artist ? `${track.artist} - ${track.album || 'Unknown Album'}` : 'Unknown Artist';
        } else {
          currentTrackTitle.textContent = 'No track playing';
          currentTrackArtist.textContent = 'Artist - Album';
          progressBar.style.width = '0%';
          currentTimeSpan.textContent = '0:00';
          durationSpan.textContent = '0:00';
        }
      }

      /**
       * Formats time in seconds into a "MM:SS" string.
       */
      function formatTime(seconds) {
        if (isNaN(seconds) || seconds < 0) return '0:00';
        const minutes = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
      }

      /**
       * Updates the progress bar and current/total time display.
       */
      function updateProgressBarAndTimer() {
        let current = 0, total = 0;

        if (currentTrackType === 'youtube' && youtubePlayer && typeof youtubePlayer.getDuration === 'function') {
            current = youtubePlayer.getCurrentTime();
            total = youtubePlayer.getDuration();
        } else if (audio && !isNaN(audio.duration)) {
            current = audio.currentTime;
            total = audio.duration;
        }

        currentTimeSpan.textContent = formatTime(current);
        durationSpan.textContent = formatTime(total);
        progressBar.style.width = total > 0 ? `${(current / total) * 100}%` : '0%';
      }
      
      // --- Media Session API Integration ---
      /**
       * Updates the Media Session metadata for native OS media controls.
       */
      function updateMediaSession() {
        if ('mediaSession' in navigator && currentTrackIndex > -1) {
            const track = playlist[currentTrackIndex];
            navigator.mediaSession.metadata = new MediaMetadata({
                title: track.title || 'Unknown Title',
                artist: track.artist || 'Unknown Artist',
                album: track.album || 'Unknown Album',
                artwork: [
                    // You could fetch album art here if available
                    { src: '/icons/icon-192x192.png', sizes: '192x192', type: 'image/png' },
                    { src: '/icons/icon-512x512.png', sizes: '512x512', type: 'image/png' },
                ]
            });
        }
      }

      /**
       * Sets up the action handlers for the Media Session API.
       */
      function setupMediaSessionHandlers() {
          if ('mediaSession' in navigator) {
              navigator.mediaSession.setActionHandler('play', togglePlayPause);
              navigator.mediaSession.setActionHandler('pause', togglePlayPause);
              navigator.mediaSession.setActionHandler('previoustrack', playPrevTrack);
              navigator.mediaSession.setActionHandler('nexttrack', playNextTrack);
          }
      }

      // --- Web Notifications ---
      /**
       * Requests permission for Web Notifications.
       */
      function requestNotificationPermission() {
          if (!('Notification' in window)) {
              console.warn("This browser does not support notifications.");
              return;
          }
          if (Notification.permission === 'granted') {
              notificationPermission = 'granted';
          } else if (Notification.permission === 'denied') {
              notificationPermission = 'denied';
          } else {
              Notification.requestPermission().then(permission => {
                  notificationPermission = permission;
                  if (permission === 'granted') {
                      showUIMessage('Notification permission granted!', 'success', 2000);
                  } else {
                      showUIMessage('Notification permission denied. Cannot show "Now Playing" alerts.', 'info', 3000);
                  }
              });
          }
      }

      /**
       * Sends a "Now Playing" notification.
       */
      function sendNowPlayingNotification() {
          if (notificationPermission === 'granted' && currentTrackIndex !== -1 && playlist[currentTrackIndex]) {
              const track = playlist[currentTrackIndex];
              const title = track.title || 'Unknown Title';
              const artist = track.artist || 'Unknown Artist';
              const album = track.album || 'Unknown Album';

              new Notification('Now Playing', {
                  body: `${title}\n${artist} - ${album}`,
                  icon: '/icons/icon-192x192.png', // Use your app icon
                  silent: true // Prevents notification sound/vibration
              });
          }
      }


      // --- Track Adding and Rendering ---
      /**
       * Adds local audio files selected by the user to the library and IndexedDB.
       */
      async function addLocalFiles(files) {
        let filesAdded = 0;
        for (const file of files) {
          if (file.type.startsWith('audio/')) {
            const track = {
              id: Date.now() + Math.random(), // Simple unique ID
              name: file.name,
              file: file, // Store the File object directly
              type: 'local',
              title: file.name.replace(/\.[^/.]+$/, ""), // Remove extension for title
              artist: 'Unknown Artist', // Placeholder, can be parsed from metadata
              album: 'Unknown Album',
              genre: 'Unknown Genre'
            };
            await saveTrackToIndexedDB(track);
            filesAdded++;
          }
        }
        if (filesAdded > 0) {
            await loadTracksFromIndexedDB();
            renderLibraryList('all');
            showUIMessage(`Added ${filesAdded} local file(s)`, 'success');
        }
      }

      /**
       * Saves a track object to IndexedDB.
       */
      async function saveTrackToIndexedDB(track) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(IDB_TRACKS_STORE_NAME, 'readwrite');
          const store = transaction.objectStore(IDB_TRACKS_STORE_NAME);
          const request = store.add(track);
          request.onsuccess = () => resolve();
          request.onerror = (event) => reject(event.target.error);
        });
      }

      /**
       * Loads all tracks from IndexedDB into the global library array.
       */
      async function loadTracksFromIndexedDB() {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(IDB_TRACKS_STORE_NAME, 'readonly');
          const store = transaction.objectStore(IDB_TRACKS_STORE_NAME);
          const request = store.getAll();
          request.onsuccess = (event) => {
            library = event.target.result.filter(t => t.type === 'local');
            resolve();
          };
          request.onerror = (event) => reject(event.target.error);
        });
      }

      /**
       * Saves the current playlist to IndexedDB with a given name.
       * Only stores essential track info (id, type, url, videoId) to reconstruct later.
       */
      async function saveCurrentPlaylist() {
          const playlistName = prompt("Enter a name for your playlist:");
          if (!playlistName || playlistName.trim() === '') {
              showUIMessage("Playlist name cannot be empty.", 'info');
              return;
          }

          // Create a simplified version of the playlist to save
          // We only need enough info to identify and re-add tracks
          const simplifiedPlaylist = playlist.map(track => ({
              id: track.id,
              type: track.type,
              url: track.url || null, // For streams
              videoId: track.videoId || null, // For YouTube
              // Local files will be re-matched by their ID from the main library
              title: track.title, // Include title for easier display during load
              artist: track.artist,
              album: track.album,
              genre: track.genre
          }));

          try {
              const transaction = db.transaction(IDB_PLAYLISTS_STORE_NAME, 'readwrite');
              const store = transaction.objectStore(IDB_PLAYLISTS_STORE_NAME);
              await new Promise((resolve, reject) => {
                  const request = store.put({ name: playlistName.trim(), tracks: simplifiedPlaylist });
                  request.onsuccess = () => resolve();
                  request.onerror = (event) => reject(event.target.error);
              });
              showUIMessage(`Playlist "${playlistName}" saved successfully!`, 'success');
          } catch (error) {
              console.error("Error saving playlist:", error);
              showUIMessage("Failed to save playlist.", 'error');
          }
      }

      /**
       * Loads a saved playlist from IndexedDB and replaces the current playlist.
       */
      async function loadSavedPlaylist() {
          try {
              const transaction = db.transaction(IDB_PLAYLISTS_STORE_NAME, 'readonly');
              const store = transaction.objectStore(IDB_PLAYLISTS_STORE_NAME);
              const savedPlaylists = await new Promise((resolve, reject) => {
                  const request = store.getAll();
                  request.onsuccess = (event) => resolve(event.target.result);
                  request.onerror = (event) => reject(event.target.error);
              });

              if (savedPlaylists.length === 0) {
                  showUIMessage("No saved playlists found.", 'info');
                  return;
              }

              // Create a selection prompt for the user
              let playlistOptions = savedPlaylists.map((p, i) => `${i + 1}. ${p.name}`).join('\n');
              const selection = prompt(`Saved Playlists:\n${playlistOptions}\nEnter the number of the playlist to load:`);

              const selectedIndex = parseInt(selection) - 1;
              if (isNaN(selectedIndex) || selectedIndex < 0 || selectedIndex >= savedPlaylists.length) {
                  showUIMessage("Invalid selection.", 'info');
                  return;
              }

              const selectedPlaylistData = savedPlaylists[selectedIndex].tracks;
              const newPlaylist = [];

              // Reconstruct the full track objects for the new playlist
              for (const simplifiedTrack of selectedPlaylistData) {
                  if (simplifiedTrack.type === 'local') {
                      // Find the full local track object from the library
                      const fullTrack = library.find(t => t.id === simplifiedTrack.id);
                      if (fullTrack) {
                          newPlaylist.push(fullTrack);
                      } else {
                          console.warn(`Local track with ID ${simplifiedTrack.id} not found in library. Skipping.`);
                      }
                  } else if (simplifiedTrack.type === 'stream' || simplifiedTrack.type === 'youtube') {
                      // For streams/YouTube, simplified data is often enough or can be reconstructed
                      // Ensure all properties needed for playback/display are present
                      let fullTrack = { ...simplifiedTrack }; // Start with saved properties
                      // Add default/placeholder properties if missing (e.g., title, artist)
                      if (!fullTrack.title) {
                          if (fullTrack.type === 'youtube') fullTrack.title = `YouTube Video ID: ${fullTrack.videoId}`;
                          else fullTrack.title = `Stream: ${fullTrack.url.split('/').pop() || 'Untitled Stream'}`;
                      }
                      if (!fullTrack.artist) fullTrack.artist = fullTrack.type === 'youtube' ? 'YouTube' : 'Stream';
                      if (!fullTrack.album) fullTrack.album = fullTrack.type === 'youtube' ? 'YouTube Playlist' : 'Stream';

                      newPlaylist.push(fullTrack);
                  }
              }

              // Stop current playback, clear, and load new playlist
              pauseCurrentTrack();
              if (currentTrackType === 'youtube' && youtubePlayer) youtubePlayer.stopVideo();
              currentTrackIndex = -1; // Reset current track
              playlist = newPlaylist;
              renderPlaylist();
              updateCurrentTrackInfo(); // Reset info display

              showUIMessage(`Playlist "${savedPlaylists[selectedIndex].name}" loaded successfully!`, 'success');
              showTab('playlist-tab'); // Switch to playlist tab
          } catch (error) {
              console.error("Error loading playlist:", error);
              showUIMessage("Failed to load playlist.", 'error');
          }
      }

      /**
       * Clears all songs from the current playlist.
       */
      function clearPlaylist() {
          pauseCurrentTrack();
          if (currentTrackType === 'youtube' && youtubePlayer) youtubePlayer.stopVideo();
          currentTrackIndex = -1;
          playlist = [];
          renderPlaylist();
          updateCurrentTrackInfo();
          showUIMessage('Playlist cleared.', 'info');
      }


      /**
       * Renders the music library list based on the specified filter type and value.
       */
      function renderLibraryList(filterType = 'all', filterValue = '') {
        libraryList.innerHTML = ''; // Clear previous list
        let filteredLibrary = [];

        // Update active state of filter buttons
        document.querySelectorAll('.library-filter-nav button').forEach(btn => {
            btn.classList.remove('active');
        });
        const activeButton = document.getElementById(`view-${filterType}-songs-btn`) || document.getElementById(`${filterType}-filter-btn`) || document.getElementById(`view-${filterType}s-btn`);
        if (activeButton) {
            activeButton.classList.add('active');
        } else if (filterType === 'all') { // Default to 'All Songs' if no specific filter button matches
            viewAllSongsBtn.classList.add('active');
        } else if (filterType === 'clear') { // If clear filter button was clicked
            clearFilterBtn.classList.add('active');
        }


        if (filterType === 'all') {
          filteredLibrary = library;
        } else if (filterType === 'albums') {
          const albums = [...new Set(library.map(t => t.album || 'Unknown Album'))];
          if (!filterValue) { // Show album titles for selection
              albums.forEach(album => {
                  const li = document.createElement('li');
                  li.innerHTML = `
                    <div class="track-info">
                      <strong>Album: ${album}</strong>
                      <span>Click to view tracks</span>
                    </div>
                  `;
                  li.classList.add('filter-group-item');
                  li.dataset.filterValue = album;
                  li.addEventListener('click', () => renderLibraryList('albums', album));
                  libraryList.appendChild(li);
              });
              noLibraryMessage.style.display = albums.length === 0 ? 'block' : 'none';
              return; // Exit as we're showing album choices, not tracks
          } else { // Show tracks for selected album
              filteredLibrary = library.filter(track => (track.album || 'Unknown Album') === filterValue);
          }
        } else if (filterType === 'artists') {
            const artists = [...new Set(library.map(t => t.artist || 'Unknown Artist'))];
            if (!filterValue) {
                artists.forEach(artist => {
                    const li = document.createElement('li');
                    li.innerHTML = `
                      <div class="track-info">
                        <strong>Artist: ${artist}</strong>
                        <span>Click to view tracks</span>
                      </div>
                    `;
                    li.classList.add('filter-group-item');
                    li.dataset.filterValue = artist;
                    li.addEventListener('click', () => renderLibraryList('artists', artist));
                    libraryList.appendChild(li);
                });
                noLibraryMessage.style.display = artists.length === 0 ? 'block' : 'none';
                return;
            } else {
                filteredLibrary = library.filter(track => (track.artist || 'Unknown Artist') === filterValue);
            }
        } else if (filterType === 'genres') {
            const genres = [...new Set(library.map(t => t.genre || 'Unknown Genre'))];
            if (!filterValue) {
                genres.forEach(genre => {
                    const li = document.createElement('li');
                    li.innerHTML = `
                      <div class="track-info">
                        <strong>Genre: ${genre}</strong>
                        <span>Click to view tracks</span>
                      </div>
                    `;
                    li.classList.add('filter-group-item');
                    li.dataset.filterValue = genre;
                    li.addEventListener('click', () => renderLibraryList('genres', genre));
                    libraryList.appendChild(li);
                });
                noLibraryMessage.style.display = genres.length === 0 ? 'block' : 'none';
                return;
            } else {
                filteredLibrary = library.filter(track => (track.genre || 'Unknown Genre') === filterValue);
            }
        }

        noLibraryMessage.style.display = filteredLibrary.length === 0 ? 'block' : 'none';

        filteredLibrary.forEach((track) => {
          const li = document.createElement('li');
          li.dataset.trackId = track.id;

          li.innerHTML = `
            <div class="track-info">
              <strong>${track.title || track.name}</strong>
              <span>${track.artist || 'Unknown Artist'} - ${track.album || 'Unknown Album'}</span>
            </div>
            <div class="playlist-actions">
                <button class="add-to-playlist-btn" data-track-id="${track.id}" title="Add to Playlist">‚ûï</button>
            </div>
          `;
          libraryList.appendChild(li);

          li.querySelector('.add-to-playlist-btn').addEventListener('click', (event) => {
            event.stopPropagation();
            const trackIdToAdd = parseFloat(event.target.dataset.trackId);
            const trackToAdd = library.find(t => t.id === trackIdToAdd);
            if (trackToAdd && !playlist.some(p => p.id === trackToAdd.id && p.type === trackToAdd.type)) {
                playlist.push(trackToAdd);
                renderPlaylist();
                showUIMessage(`Added "${trackToAdd.title}" to playlist`, 'success');
                showTab('playlist-tab');
            } else {
                showUIMessage(`"${trackToAdd.title}" is already in the playlist`, 'info');
            }
          });
        });
      }

      /**
       * Renders the current playlist in the playlist tab.
       */
      function renderPlaylist() {
        playlistList.innerHTML = '';
        noPlaylistMessage.style.display = playlist.length === 0 ? 'block' : 'none';

        if (playlist.length === 0) return;

        playlist.forEach((track, index) => {
          const li = document.createElement('li');
          li.dataset.index = index;
          li.classList.toggle('playing', index === currentTrackIndex);
          li.draggable = true; // Enable drag for reordering

          const displayTitle = track.type === 'youtube' ? `YouTube: ${track.title}` : (track.title || track.name);
          const displayArtist = track.artist ? `${track.artist} - ${track.album || 'Unknown Album'}` : 'Unknown Artist';

          li.innerHTML = `
            <div class="track-info">
              <strong>${displayTitle}</strong>
              <span>${displayArtist}</span>
            </div>
            <div class="playlist-actions">
              <button class="remove-from-playlist-btn" data-index="${index}" title="Remove from Playlist">üóëÔ∏è</button>
            </div>
          `;
          playlistList.appendChild(li);

          li.addEventListener('click', (event) => {
            // Only play if the click is not on the remove button
            if (!event.target.closest('.remove-from-playlist-btn')) {
                currentTrackIndex = index;
                playCurrentTrack();
            }
          });

          li.querySelector('.remove-from-playlist-btn').addEventListener('click', (event) => {
            event.stopPropagation();
            const indexToRemove = parseInt(event.target.dataset.index);
            
            if (indexToRemove === currentTrackIndex) {
              pauseCurrentTrack();
              if (currentTrackType === 'youtube' && youtubePlayer) youtubePlayer.stopVideo();
              currentTrackIndex = -1;
              updateCurrentTrackInfo();
            } else if (indexToRemove < currentTrackIndex) {
              currentTrackIndex--;
            }
            playlist.splice(indexToRemove, 1);
            renderPlaylist(); // Re-render to update indices and display
            showUIMessage('Track removed from playlist.', 'info');
          });
        });
        setupDragAndDrop(); // Setup drag-and-drop after rendering
      }

      /**
       * Sets up drag and drop functionality for playlist items.
       */
      function setupDragAndDrop() {
          let dragSrcEl = null;

          function handleDragStart(e) {
              dragSrcEl = this;
              e.dataTransfer.effectAllowed = 'move';
              e.dataTransfer.setData('text/html', this.innerHTML);
              this.classList.add('dragging');
          }

          function handleDragOver(e) {
              e.preventDefault(); // Necessary to allow drop
              e.dataTransfer.dropEffect = 'move';
              if (this !== dragSrcEl && !this.classList.contains('drag-over')) {
                  this.classList.add('drag-over');
              }
          }

          function handleDragLeave(e) {
              this.classList.remove('drag-over');
          }

          function handleDrop(e) {
              e.stopPropagation(); // Stops some browsers from redirecting.
              this.classList.remove('drag-over');

              if (dragSrcEl !== this) {
                  const fromIndex = parseInt(dragSrcEl.dataset.index);
                  const toIndex = parseInt(this.dataset.index);

                  // Reorder the playlist array
                  const [movedItem] = playlist.splice(fromIndex, 1);
                  playlist.splice(toIndex, 0, movedItem);

                  // Adjust currentTrackIndex if the playing song was moved
                  if (currentTrackIndex === fromIndex) {
                      currentTrackIndex = toIndex;
                  } else if (currentTrackIndex >= Math.min(fromIndex, toIndex) && currentTrackIndex <= Math.max(fromIndex, toIndex)) {
                      // If the playing song was between the start and end of the move
                      if (fromIndex < toIndex) { // Moved down
                          currentTrackIndex--;
                      } else { // Moved up
                          currentTrackIndex++;
                      }
                  }
                  renderPlaylist(); // Re-render the playlist to reflect new order and indices
                  showUIMessage('Playlist reordered.', 'info', 1500);
              }
          }

          function handleDragEnd(e) {
              document.querySelectorAll('.playlist-list li').forEach(item => {
                  item.classList.remove('dragging', 'drag-over');
              });
          }

          document.querySelectorAll('.playlist-list li').forEach(item => {
              item.addEventListener('dragstart', handleDragStart, false);
              item.addEventListener('dragover', handleDragOver, false);
              item.addEventListener('dragleave', handleDragLeave, false);
              item.addEventListener('drop', handleDrop, false);
              item.addEventListener('dragend', handleDragEnd, false);
          });
      }


      /**
       * Shows the specified tab content and updates tab button active state.
       */
      function showTab(tabId) {
        document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
        document.getElementById(tabId).classList.add('active');

        document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
        document.getElementById(`${tabId}-btn`).classList.add('active');
      }

      /**
       * Clears any active library filter and displays all songs.
       */
      function clearFilter() {
        renderLibraryList('all');
        // Ensure only 'All Songs' button is active after clearing filter
        document.querySelectorAll('.library-filter-nav button').forEach(btn => btn.classList.remove('active'));
        viewAllSongsBtn.classList.add('active');
      }
      
      /**
       * Validates URL input fields in real-time.
       * @param {HTMLInputElement} inputElement The input element to validate.
       * @param {RegExp} regex The regular expression to test against.
       */
      function validateUrlInput(inputElement, regex) {
          const url = inputElement.value.trim();
          if (url === '') {
              inputElement.classList.remove('valid', 'invalid');
              return;
          }
          if (regex.test(url)) {
              inputElement.classList.add('valid');
              inputElement.classList.remove('invalid');
          } else {
              inputElement.classList.add('invalid');
              inputElement.classList.remove('valid');
          }
      }

      // --- Event Listeners ---
      /**
       * Initializes all event listeners for player controls, inputs, and tabs.
       */
      function initEventListeners() {
        addMusicFileInput.addEventListener('change', (event) => addLocalFiles(event.target.files));

        playStreamBtn.addEventListener('click', () => {
          const url = streamUrlInput.value.trim();
          if (url) {
            const streamTrack = {
              id: Date.now() + Math.random(), // Simple unique ID
              name: url.split('/').pop() || 'Streaming Audio',
              url: url, type: 'stream', title: 'Streaming Audio', artist: 'Remote Stream', album: 'Live Stream'
            };
            // Check for duplicates before adding
            if (!playlist.some(t => t.url === url && t.type === 'stream')) {
                playlist.push(streamTrack);
                currentTrackIndex = playlist.length - 1;
                playCurrentTrack();
                streamUrlInput.value = '';
                streamUrlInput.classList.remove('valid', 'invalid');
                showUIMessage(`Added stream: ${streamTrack.title}`, 'success');
            } else {
                showUIMessage('This stream is already in the playlist.', 'info');
            }
          } else {
            showUIMessage('Please enter a valid stream URL.', 'error');
          }
        });

        playYoutubeBtn.addEventListener('click', () => {
            const youtubeUrl = youtubeUrlInput.value.trim();
            const videoId = extractYouTubeVideoId(youtubeUrl);
            if (videoId) {
                const youtubeTrack = {
                    id: videoId, url: youtubeUrl, videoId: videoId, type: 'youtube',
                    title: 'YouTube Video', artist: 'YouTube', album: 'YouTube'
                };
                const existingIndex = playlist.findIndex(t => t.id === videoId && t.type === 'youtube');
                if (existingIndex === -1) {
                    playlist.push(youtubeTrack);
                    currentTrackIndex = playlist.length - 1;
                    showUIMessage(`Added YouTube video: ${youtubeTrack.title}`, 'success');
                } else {
                    currentTrackIndex = existingIndex;
                    showUIMessage(`YouTube video is already in playlist. Playing existing.`, 'info');
                }
                playCurrentTrack();
                youtubeUrlInput.value = '';
                youtubeUrlInput.classList.remove('valid', 'invalid');
            } else {
                showUIMessage('Please enter a valid YouTube video URL.', 'error');
            }
        });

        addYoutubePlaylistBtn.addEventListener('click', () => {
            const playlistUrl = youtubePlaylistUrlInput.value.trim();
            const playlistId = extractYouTubePlaylistId(playlistUrl);
            if (playlistId) {
                addYouTubePlaylist(playlistId);
                youtubePlaylistUrlInput.value = '';
                youtubePlaylistUrlInput.classList.remove('valid', 'invalid');
            } else {
                showUIMessage('Please enter a valid YouTube playlist URL.', 'error');
            }
        });
        
        // Real-time URL validation
        const youtubeVideoRegex = /^(https?:\/\/)?(www\.)?(youtube\.com\/watch\?v=|youtu\.be\/)[a-zA-Z0-9_-]{11}/;
        const youtubePlaylistRegex = /^(https?:\/\/)?(www\.)?youtube\.com\/playlist\?list=[a-zA-Z0-9_-]+/;
        // Improved stream regex to be more permissive for common audio formats
        const streamRegex = /^(https?:\/\/).*\.(mp3|aac|ogg|m4a|wav|flac)(\?.*)?$/i;

        youtubeUrlInput.addEventListener('input', () => validateUrlInput(youtubeUrlInput, youtubeVideoRegex));
        youtubePlaylistUrlInput.addEventListener('input', () => validateUrlInput(youtubePlaylistUrlInput, youtubePlaylistRegex));
        streamUrlInput.addEventListener('input', () => validateUrlInput(streamUrlInput, streamRegex));

        // Player controls
        playPauseBtn.addEventListener('click', togglePlayPause);
        prevBtn.addEventListener('click', playPrevTrack);
        nextBtn.addEventListener('click', playNextTrack);
        repeatBtn.addEventListener('click', toggleRepeatMode); // New repeat button listener
        shufflePlaylistBtn.addEventListener('click', shufflePlaylist); // New shuffle button listener
        clearPlaylistBtn.addEventListener('click', clearPlaylist); // New clear playlist button listener


        // Audio element events
        audio.addEventListener('timeupdate', updateProgressBarAndTimer);
        audio.addEventListener('ended', handleTrackEnded); // Use common ended handler
        audio.addEventListener('play', () => { isPlaying = true; updatePlayPauseButton(); updateMediaSession(); showLoadingIndicator(false); sendNowPlayingNotification(); });
        audio.addEventListener('pause', () => { isPlaying = false; updatePlayPauseButton(); showLoadingIndicator(false); });
        audio.addEventListener('waiting', () => { if (isPlaying) showLoadingIndicator(true); }); // Show loading when buffering
        audio.addEventListener('playing', () => showLoadingIndicator(false)); // Hide loading when playback resumes
        audio.addEventListener('error', () => { showUIMessage('Error playing audio file.', 'error'); showLoadingIndicator(false); });

        volumeSlider.addEventListener('input', (event) => {
          const volume = event.target.value / 100;
          audio.volume = volume;
          if (youtubePlayer && typeof youtubePlayer.setVolume === 'function') {
              youtubePlayer.setVolume(event.target.value);
          }
        });

        progressBarContainer.addEventListener('click', (event) => {
          const clickX = event.clientX - progressBarContainer.getBoundingClientRect().left;
          const percentage = clickX / progressBarContainer.offsetWidth;
          
          if (currentTrackType === 'youtube' && youtubePlayer && youtubePlayer.getDuration() > 0) {
              youtubePlayer.seekTo(youtubePlayer.getDuration() * percentage, true);
          } else if (audio && !isNaN(audio.duration) && audio.duration > 0) {
              audio.currentTime = audio.duration * percentage;
          }
        });

        // Tabs and filters
        libraryTabBtn.addEventListener('click', () => showTab('library-tab'));
        playlistTabBtn.addEventListener('click', () => showTab('playlist-tab'));
        viewAllSongsBtn.addEventListener('click', () => renderLibraryList('all'));
        viewAlbumsBtn.addEventListener('click', () => renderLibraryList('albums'));
        viewArtistsBtn.addEventListener('click', () => renderLibraryList('artists'));
        viewGenresBtn.addEventListener('click', () => renderLibraryList('genres'));
        clearFilterBtn.addEventListener('click', clearFilter);

        // New playlist saving/loading buttons
        savePlaylistBtn.addEventListener('click', saveCurrentPlaylist);
        loadPlaylistBtn.addEventListener('click', loadSavedPlaylist);

        // Keyboard Shortcuts
        document.addEventListener('keydown', (event) => {
            // Prevent default browser actions for media keys if handled by player
            if (event.key === ' ' || event.key === 'ArrowRight' || event.key === 'ArrowLeft' || event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                event.preventDefault();
            }

            switch (event.key) {
                case ' ': // Spacebar for Play/Pause
                    togglePlayPause();
                    break;
                case 'ArrowRight': // Right arrow for Next Track
                    playNextTrack();
                    break;
                case 'ArrowLeft': // Left arrow for Previous Track
                    playPrevTrack();
                    break;
                case 'ArrowUp': // Up arrow for Volume Up
                    volumeSlider.value = Math.min(100, parseInt(volumeSlider.value) + 5);
                    volumeSlider.dispatchEvent(new Event('input')); // Trigger input event to update volume
                    break;
                case 'ArrowDown': // Down arrow for Volume Down
                    volumeSlider.value = Math.max(0, parseInt(volumeSlider.value) - 5);
                    volumeSlider.dispatchEvent(new Event('input')); // Trigger input event to update volume
                    break;
                case 'm': // Mute/Unmute (simple toggle)
                    if (audio.volume > 0) {
                        audio.dataset.previousVolume = audio.volume; // Store current volume
                        audio.volume = 0;
                        volumeSlider.value = 0;
                    } else {
                        audio.volume = parseFloat(audio.dataset.previousVolume) || 0.75; // Restore or default
                        volumeSlider.value = audio.volume * 100;
                    }
                    volumeSlider.dispatchEvent(new Event('input')); // Update slider visually
                    break;
                case 'r': // 'r' for Repeat Mode
                    toggleRepeatMode();
                    break;
                case 's': // 's' for Shuffle
                    shufflePlaylist();
                    break;
            }
        });
      }

      // --- Initialization ---
      /**
       * Initializes the application.
       */
      async function init() {
        await openIndexedDB();
        await loadTracksFromIndexedDB();
        
        initEventListeners();
        setupMediaSessionHandlers();
        requestNotificationPermission(); // Request notification permission on init
        
        // Handle URL hash for PWA shortcuts
        const tab = window.location.hash.substring(1);
        if (tab === 'library') {
            showTab('library-tab');
        } else {
            showTab('playlist-tab');
        }

        renderPlaylist();
        renderLibraryList('all');
        setupVisualizer();
      }

      init();

      // Service Worker Registration
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('/service-worker.js')
            .then((reg) => console.log('Service Worker registered.', reg))
            .catch((err) => console.error('Service Worker registration failed:', err));
        });
      }
    })();
  </script>
</body>
</html>
 